# -*- coding: utf-8 -*-
from __future__ import (division, absolute_import, print_function,
                        unicode_literals)

from collections import defaultdict
from copy import deepcopy
import re


# represent outcome of input argument preprocessing.
class Token(object):
    POSIX_OPTION = 0
    GNU_OPTION = 1
    GENERAL_ELEMENT = 2

    def __init__(self, type_id, value):
        self.type_id = type_id
        self.value = value

    def __eq__(self, other):
        return (self.type_id == other.type_id
                and self.value == other.value)

    def __hash__(self):
        # for dict and set.
        return hash(self.type_id) ^ hash(self.value)

    def __repr__(self):
        return '<Token ({0}, {1})>'.format(self.type_id, self.value)


# store attributes generated by `clidoc` front end.
class Info(object):
    # root of AST.
    doc_node = None
    # `set` of `Token`.
    bound_options = None
    unbound_options = None
    arguments = None
    oom_bound_options = None
    oom_arguments = None
    commands = None
    # `dict` contains mapping from `Token` to string.
    default_values = None
    # `dict` contains mapping from `Token` to `Token`.
    option_to_representative_option = None
    # string of user defined doc.
    doc_text = None

    # shared by all match state object.
    _tokens = []
    _token_skip_table = defaultdict(list)

    @classmethod
    def load_tokens(cls, tokens):
        cls._tokens = tokens
        # construct `_token_skip_table`
        cls._token_skip_table = defaultdict(list)
        for index, token in enumerate(tokens):
            token_skip_table[token].append(index)

    @classmethod
    def get_tokens(cls):
        return cls._tokens

    @classmethod
    def get_token(cls, index):
        return self._tokens.get(index, None)

    @classmethod
    def search_match_token_indices(cls, key):
        return cls._token_skip_table.get(key, [])

    @classmethod
    def is_boolean_key(cls, key):
        return key in cls.unbound_options or key in cls.commands

    @classmethod
    def is_string_key(cls, key):
        return key in cls.bound_options or key in cls.arguments

    @classmethod
    def is_string_list_key(cls, key):
        return key in cls.oom_bound_options or key in cls.oom_arguments


# manage match state of input arguments.
class MatchState(object):

    def _add_outcome(self, attr_name, tokens, callback):
        for token in tokens:
            getattr(self, attr_name)[token] = callback(token)

    def _add_boolean_outcome(self, tokens):
        self._add_outcome(
            '_boolean_outcome',
            tokens,
            lambda x: False,
        )

    def _add_string_outcome(self, tokens, default_values):
        self._add_outcome(
            '_string_outcome',
            tokens,
            lambda token: default_values.get(token, ""),
        )

    def _add_string_list_outcome(self, tokens):
        self._add_outcome(
            '_string_list_outcome',
            tokens,
            lambda x: [],
        )

    def __init__(self):
        self._consumed_flags = [False] * len(Info.get_tokens())

        self._boolean_outcome = {}
        self._add_boolean_outcome(Info.unbound_options)
        self._add_boolean_outcome(Info.commands)

        self._string_outcome = {}
        self._add_string_outcome(Info.bound_options, Info.default_values)
        self._add_string_outcome(Info.arguments, Info.default_values)

        self._string_list_outcome = {}
        self._add_string_list_outcome(info.oom_bound_options)
        self._add_string_list_outcome(info.oom_arguments)

    def add_boolean_outcome(self, key):
        self._boolean_outcome[key] = True

    def add_string_outcome(self, key, value):
        self._string_outcome[key] = value

    def add_string_list_outcome(self, key, value):
        self._string_list_outcome[key].append(value)

    def set_consumed_flag(self, index):
        self._consumed_flags[index] = True

    def get_consumed_flag(self, index):
        return self._consumed_flags[index]


class MatchStateManager(object):

    @classmethod
    def init(cls):
        cls._match_state = MatchState()
        cls._state_stack = []

    @classmethod
    def push_rollback_point(cls):
        cls._state_stack.append(deepcopy(cls._match_state))

    @classmethod
    def pop_rollback_point(cls):
        return cls._state_stack.pop()

    @classmethod
    def rollback(cls):
        cls._match_state = cls.pop_rollback_point()

    @classmethod
    def _prepare_unconsumed_index(cls, key):
        for index in Info.search_match_token_indices(key):
            if not self._match_state.get_consumed_flag(index):
                return index
        return None

    @classmethod
    def try_to_generate_boolean_outcome(cls, key):
        index = cls._prepare_unconsumed_index(key)
        if index is None:
            return False
        # change match state.
        self._match_state.add_boolean_outcome(key)
        self._match_state.set_consumed_flag(index)
        return True

    @classmethod
    def _try_to_generate_outcome_with_value(cls, key, store_key_value_pair):

        def check_next_token(index):
            if index is None:
                return False, None
            next_token = Info.get_token(index)
            if next_token is None:
                return False, None
            # 1. GENERAL_ELEMENT.
            # 2. not consumed.
            flag = (next_token.type_id == Token.GENERAL_ELEMENT
                    and not cls._match_state.get_consumed_flag[index])
            value = next_token.value
            return flag, value

        index = cls._prepare_unconsumed_index(key)
        flag, value = check_next_token(index + 1)
        if flag:
            cls._match_state.set_consumed_flag(index)
            cls._match_state.set_consumed_flag(index + 1)
            store_key_value_pair(key, value)
            return True
        return False

    @classmethod
    def try_to_generate_string_outcome(cls, key):
        return cls._try_to_generate_outcome_with_value(
            key,
            self._match_state.add_string_outcome,
        )

    @classmethod
    def try_to_generate_string_list_outcome(cls, key):
        return cls._try_to_generate_outcome_with_value(
            key,
            self._match_state.add_string_list_outcome,
        )


# Implement classes representing following classes:
#
# Non-terminals:
#   * Doc
#   * LogicAnd
#   * LogicXor
#   * LogicOr
#   * LogicOptional
#   * LogicOneOrMore
#
# Terminals:
#   * PosixOption
#   * GnuOption
#   * Command
#   * Argument
class Terminal(object):
    # derived class should override this attribute.
    _type_id = None

    def __init__(self, value):
        self._value = value
        self._children = []

    # generate token for matching.
    def token(self):
        return Token(self._type_id, self._value)

    def _match(self, callbacks):
        key = self.token()
        for callback in callbacks:
            if callback(key):
                return True
        return False

    # return True indicates successfully match, False otherwise.
    def match(self):
        raise Exception("Terminal")


class PosixOption(Terminal):
    _type_id = Token.POSIX_OPTION

    def match(self):
        callbacks = [
            MatchStateManager.try_to_generate_boolean_outcome,
            MatchStateManager.try_to_generate_string_outcome,
            MatchStateManager.try_to_generate_string_list_outcome,
        ]
        return self._match(callbacks)


class GnuOption(Terminal):
    _type_id = Token.GNU_OPTION

    def match(self):
        callbacks = [
            MatchStateManager.try_to_generate_boolean_outcome,
            MatchStateManager.try_to_generate_string_outcome,
            MatchStateManager.try_to_generate_string_list_outcome,
        ]
        return self._match(callbacks)


class Command(Terminal):
    _type_id = Token.GENERAL_ELEMENT

    def match(self):
        callbacks = [
            MatchStateManager.try_to_generate_boolean_outcome,
        ]
        return self._match(callbacks)


class Argument(Terminal):
    _type_id = Token.GENERAL_ELEMENT

    def match(self):
        callbacks = [
            MatchStateManager.try_to_generate_string_outcome,
            MatchStateManager.try_to_generate_string_list_outcome,
        ]
        return self._match(callbacks)


class NonTerminal(object):
    def __init__(self):
        self._children = []

    def add_child(self, child):
        self._children.append(child)

    # in case the node has only one child, return it.
    def get_forward_child(self):
        return self._children[0]

    # return True indicates successfully match, False otherwise.
    def match(self):
        raise Exception("NonTerminal")


class Doc(NonTerminal):

    def match(self):
        self.get_forward_child().match()


class LogicAnd(NonTerminal):

    def match(self):
        MatchStateManager.push_rollback_point()
        for child in self._children:
            if not child.match():
                MatchStateManager.rollback()
                return False
        MatchStateManager.pop_rollback_point()
        return True


class LogicXor(NonTerminal):

    def match(self):
        for child in self._children:
            if child.match():
                return True
        return False


class LogicOr(NonTerminal):

    def match(self):
        one_or_more = False
        for child in self._children:
            if child.match():
                one_or_more = True
        return one_or_more


class LogicOptional(NonTerminal):

    def match(self):
        self.get_forward_child().match()
        return True


class LogicOneOrMore(NonTerminal):

    def match(self):
        child = self.get_forward_child()
        counter = -1
        while True:
            counter = counter + 1
            if not child.match():
                break
        return counter > 0


# preprocessing algorithm of input arguments.
# return a list of tokens.
class ArgvPreprocessor(object):
    POSIX_OPTION = 0
    GNU_OPTION = 1
    SINGLE_DASH_CASE = 2
    DOUBLE_DASH_CASE = 3
    UNKNOW_CASE = 4

    # `argv`: input argument vector.
    # `option_to_rep_option`: a dict contains mapping from option to its
    # representative option.
    # `bound_options`: a set of bound options.
    def __init__(self, argv, option_to_rep_option, bound_options):
        # ignore `argv[0]`.
        self._argv = argv[1:]
        self._option_to_rep_option = option_to_rep_option
        self._bound_options = bound_options
        # preprocessed input arguments.
        self.tokens = []

    def _detect_argument_pattern(self, value):
        # patterns.
        ALNUM = '[a-zA-Z0-9]'
        POSIX_OPTION_PATTERN = '^\\-{}$'.format(ALNUM)
        GNU_OPTION_PATTERN = '^\\-\\-{0}({0}|\\-)+$'.format(ALNUM)

        if re.match(POSIX_OPTION_PATTERN, value):
            return self.POSIX_OPTION
        if re.match(GNU_OPTION_PATTERN, value):
            return self.GNU_OPTION
        # state: not `POSIX_OPTION` or `GNU_OPTION`.
        if len(value) <= 2:
            return self.UNKNOW_CASE
        # state: not `POSIX_OPTION` or `GNU_OPTION`.
        #        len(value) > 2.
        if value.startswith('--'):
            return self.DOUBLE_DASH_CASE
        # state: not `POSIX_OPTION` or `GNU_OPTION`.
        #        len(value) > 2.
        #        not startswith "--".
        if value.startswith('-'):
            return self.SINGLE_DASH_CASE
        # state: not `POSIX_OPTION` or `GNU_OPTION`.
        #        len(value) > 2.
        #        not startswith "-".
        return self.UNKNOW_CASE

    def _get_rep_option(self, type_id, value):
        return self._option_to_rep_option.get(Token(type_id, value), None)

    def _option_is_bound(self, option):
        return option in self._bound_options

    def _add_general_element(self, value, dst=None):
        dst = dst or self.tokens
        dst.append(
            Token(Token.GENERAL_ELEMENT, value),
        )

    def _process_option(self, type_id, value):
        option = self._get_rep_option(type_id, value)
        if option is None:
            self._add_general_element(value)
            return False
        # state: valid option.
        self.tokens.append(option)
        if self._option_is_bound(option):
            return True
        return False

    def _process_posix_option(self, value):
        return self._process_option(Token.POSIX_OPTION, value)

    def _process_gnu_option(self, value):
        return self._process_option(Token.GNU_OPTION, value)

    def _process_single_dash_case(self, value):
        # ignore '-'.
        chars = value[1:]
        tokens_cache = []

        skip_next_argument = False
        cur_char_index = 0
        for char in chars:
            option = self._get_rep_option(Token.POSIX_OPTION, '-' + char)
            if option is None:
                break
            # state: valid option.
            tokens_cache.append(option)
            if self._option_is_bound(option):
                if cur_char_index != len(chars) - 1:
                    # `char` is not the last character.
                    self._add_general_element(
                        chars[cur_char_index + 1:],
                        tokens_cache,
                    )
                else:
                    # `char` is the last character.
                    skip_next_argument = True
                # mark consumed all characters.
                cur_char_index = len(chars)
                break
            cur_char_index = cur_char_index + 1
        # check if word splitting is successful.
        if cur_char_index == len(chars):
            # merge change.
            self.tokens.extend(tokens_cache)
        else:
            self._add_general_element(value)
        return skip_next_argument

    def _process_double_dash_case(self, value):
        split_flag = False
        equal_sign_index = 0
        while True:
            equal_sign_index = value.find('=', equal_sign_index)
            if equal_sign_index in [-1, len(value) - 1]:
                # 1. cannot found '='.
                # 2. '=' is the last character.
                break

            # state: "=" is not the last character.
            option = self._get_rep_option(
                Token.GNU_OPTION,
                value[:equal_sign_index],
            )
            if option and self._option_is_bound(option):
                # find it!
                self.tokens.append(option)
                self._add_general_element(value[equal_sign_index + 1:])
                split_flag = True
                break
            # not a valid split, re-search "=" again.
            equal_sign_index = equal_sign_index + 1
        if not split_flag:
            self._add_general_element(value)
        return False

    def _process_unknow_case(self, value):
        if value == '--':
            return True
        self._add_general_element(value)
        return False

    def tokenize_argv(self):
        case_function_mapping = {
            self.POSIX_OPTION: self._process_posix_option,
            self.GNU_OPTION: self._process_gnu_option,
            self.SINGLE_DASH_CASE: self._process_single_dash_case,
            self.DOUBLE_DASH_CASE: self._process_double_dash_case,
            self.UNKNOW_CASE: self._process_unknow_case,
        }
        skip_next_argument = False
        for index, value in enumerate(self._argv):
            if skip_next_argument:
                self._add_general_element(value)
                skip_next_argument = False
                continue
            # process `value`.
            case = self._detect_argument_pattern(value)
            function = case_function_mapping[case]
            flag = function(value)
            if case != self.UNKNOW_CASE:
                skip_next_argument = flag
                continue
            # check if detecting "--".
            if case == self.UNKNOW_CASE and flag:
                for value_after_double_dash in self._argv[index + 1:]:
                    self._add_general_element(value_after_double_dash)
                break
